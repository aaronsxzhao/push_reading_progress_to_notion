<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sync">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìö</text></svg>">
    <title>Sync WeRead</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #fff;
        }
        .container { text-align: center; width: 100%; max-width: 400px; }
        .icon { font-size: 80px; margin-bottom: 20px; }
        h1 { font-size: 24px; margin-bottom: 30px; }
        .btn {
            display: block;
            width: 100%;
            padding: 20px;
            font-size: 20px;
            font-weight: 600;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            margin: 10px 0;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }
        .btn-primary:hover { transform: translateY(-2px); }
        .btn-primary:active { transform: scale(0.98); }
        .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .btn-cancel {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
            display: none;
        }
        .btn-cancel:hover { transform: translateY(-2px); }
        .btn-cancel:active { transform: scale(0.98); }
        .status {
            padding: 15px;
            border-radius: 12px;
            margin: 20px 0;
            min-height: 50px;
            font-size: 16px;
        }
        .status.info { background: rgba(255,255,255,0.1); }
        .status.success { background: rgba(34,197,94,0.3); }
        .status.error { background: rgba(239,68,68,0.3); }
        .status.running { background: rgba(59,130,246,0.3); animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        
        /* Progress bar styles */
        .progress-container {
            display: none;
            margin: 20px 0;
            text-align: left;
        }
        .progress-bar-bg {
            width: 100%;
            height: 24px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%);
            border-radius: 12px;
            transition: width 0.5s ease;
            width: 0%;
        }
        .progress-text {
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.9;
            text-align: center;
        }
        .progress-stats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        .config {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            text-align: left;
        }
        .config summary { cursor: pointer; font-weight: 600; padding: 10px 0; }
        .config input {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 16px;
        }
        .config input::placeholder { color: rgba(255,255,255,0.4); }
        .config label { display: block; margin-top: 15px; font-size: 14px; opacity: 0.8; }
        .config .save-btn {
            background: rgba(255,255,255,0.15);
            color: #fff;
            padding: 12px;
            font-size: 14px;
            margin-top: 15px;
        }
        .footer { margin-top: 30px; font-size: 12px; opacity: 0.5; }
        .footer a { color: #60a5fa; }
        .checkmark { color: #22c55e; margin-left: 5px; }
        
        .bookmarklet-link {
            display: block;
            padding: 16px;
            margin: 12px 0;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: #fff;
            font-weight: 700;
            font-size: 16px;
            text-align: center;
            text-decoration: none;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
            -webkit-touch-callout: default;
        }
        .steps { text-align: left; font-size: 13px; line-height: 1.8; opacity: 0.85; margin-top: 12px; }
        .steps li { margin: 4px 0; }
        .cookie-status { font-size: 13px; margin-top: 10px; padding: 10px; border-radius: 8px; }
        .cookie-status.ok { background: rgba(34,197,94,0.2); }
        .cookie-status.expired { background: rgba(239,68,68,0.2); }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">üìö</div>
        <h1>WeRead ‚Üí Notion</h1>
        
        <button id="syncBtn" class="btn btn-primary" onclick="triggerSync()">Sync Now</button>
        <button id="cancelBtn" class="btn btn-cancel" onclick="cancelSync()">Cancel Sync</button>
        
        <div id="status" class="status info">Tap to sync your reading progress</div>
        
        <div id="progressContainer" class="progress-container">
            <div class="progress-bar-bg">
                <div id="progressBar" class="progress-bar-fill"></div>
            </div>
            <div id="progressText" class="progress-text">Preparing...</div>
            <div class="progress-stats">
                <span id="progressSynced">0 synced</span>
                <span id="progressErrors">0 errors</span>
            </div>
        </div>
        
        <details class="config" id="configPanel">
            <summary>Setup <span id="configStatus"></span></summary>
            
            <label>GitHub Token:</label>
            <input type="text" id="githubToken" placeholder="ghp_xxxxxxxxxxxx" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
            <small style="opacity:0.5;font-size:12px;">
                <a href="https://github.com/settings/tokens/new?scopes=repo,workflow&description=weread-sync" target="_blank" style="color:#60a5fa;">Get token here</a> (select repo + workflow)
            </small>
            
            <label>GitHub Repo:</label>
            <input type="text" id="githubRepo" placeholder="username/push_reading_progress_to_notion" autocorrect="off" autocapitalize="off" spellcheck="false">
            
            <label>Gist ID <span style="opacity:0.5;">(for cookie sync)</span>:</label>
            <input type="text" id="gistId" placeholder="abc123def456..." autocorrect="off" autocapitalize="off" spellcheck="false">
            <small style="opacity:0.5;font-size:12px;">
                From your GitHub Secrets COOKIE_GIST_ID value
            </small>
            
            <button type="button" class="btn save-btn" id="saveBtn">Save Configuration</button>
        </details>
        
        <details class="config" style="margin-top:15px;" id="cookiePanel">
            <summary>Cookie Refresher <span id="cookieStatus"></span></summary>
            
            <p style="font-size:13px;opacity:0.8;margin-bottom:12px;">
                When WeRead cookies expire, use this bookmarklet to refresh them from your phone.
            </p>
            
            <div id="bookmarkletContainer" style="display:none;">
                <a id="bookmarkletLink" class="bookmarklet-link" href="#">
                    Refresh WeRead Cookies
                </a>
                
                <div id="cookieStatusMsg" class="cookie-status" style="display:none;"></div>
                
                <ol class="steps">
                    <li><strong>Long-press</strong> the button above and choose <strong>"Copy Link"</strong></li>
                    <li>Open <strong>weread.qq.com</strong> in Safari/Chrome and <strong>log in</strong></li>
                    <li>Create a <strong>new bookmark</strong> for that page (tap Share ‚Üí Add Bookmark)</li>
                    <li><strong>Edit the bookmark</strong>: replace the URL with the copied link</li>
                    <li>When cookies expire, open weread.qq.com and <strong>tap the bookmark</strong></li>
                </ol>
                
                <button type="button" class="btn save-btn" id="testBookmarkletBtn">Test Gist Connection</button>
            </div>
            
            <div id="bookmarkletMissing" style="font-size:13px;opacity:0.7;">
                <p>Requires GitHub Token and Gist ID in Setup above.</p>
            </div>
        </details>
        
        <details class="config" style="margin-top:15px;">
            <summary>Debug Info</summary>
            <div id="debugInfo" style="font-size:12px;word-break:break-all;margin-top:10px;"></div>
            <button class="btn save-btn" onclick="testConnection()">Test Connection</button>
        </details>
        
        <p class="footer">
            Powered by <a href="https://github.com/actions" target="_blank">GitHub Actions</a>
        </p>
    </div>

    <script>
        let currentRunId = null;
        let pollInterval = null;
        
        function loadConfig() {
            const token = localStorage.getItem('gh_token');
            const repo = localStorage.getItem('gh_repo');
            const gistId = localStorage.getItem('gh_gist_id');
            if (token) document.getElementById('githubToken').value = token;
            if (repo) document.getElementById('githubRepo').value = repo;
            if (gistId) document.getElementById('gistId').value = gistId;
            updateConfigStatus();
            updateBookmarklet();
        }
        
        function updateConfigStatus() {
            const token = localStorage.getItem('gh_token');
            const repo = localStorage.getItem('gh_repo');
            const status = document.getElementById('configStatus');
            const panel = document.getElementById('configPanel');
            
            if (token && repo) {
                status.innerHTML = '<span class="checkmark">‚úì</span>';
                panel.open = false;
            } else {
                status.innerHTML = '<span style="color:#f87171;">‚ö† Required</span>';
                panel.open = true;
            }
        }
        
        function saveConfig() {
            var tokenEl = document.getElementById('githubToken');
            var repoEl = document.getElementById('githubRepo');
            var gistEl = document.getElementById('gistId');
            
            // Force iOS to flush pending input
            tokenEl.blur();
            repoEl.blur();
            gistEl.blur();
            
            var token = tokenEl.value.trim();
            var repo = repoEl.value.trim();
            var gistId = gistEl.value.trim();
            
            if (!token || !repo) {
                updateStatus('Please fill in Token and Repo fields', 'error');
                return;
            }
            
            try {
                localStorage.setItem('gh_token', token);
                localStorage.setItem('gh_repo', repo);
                if (gistId) {
                    localStorage.setItem('gh_gist_id', gistId);
                } else {
                    localStorage.removeItem('gh_gist_id');
                }
                
                var saved = localStorage.getItem('gh_token');
                if (saved === token) {
                    updateStatus('Saved! Tap Sync Now to test.', 'success');
                } else {
                    updateStatus('Save failed - try disabling private browsing', 'error');
                    return;
                }
            } catch (e) {
                updateStatus('Cannot save: ' + e.message, 'error');
                return;
            }
            
            updateBookmarklet();
            setTimeout(function() { updateConfigStatus(); }, 1500);
        }
        
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
        }
        
        function showProgress(current, total, synced, errors) {
            const container = document.getElementById('progressContainer');
            const bar = document.getElementById('progressBar');
            const text = document.getElementById('progressText');
            const syncedEl = document.getElementById('progressSynced');
            const errorsEl = document.getElementById('progressErrors');
            
            container.style.display = 'block';
            
            const percent = total > 0 ? Math.round((current / total) * 100) : 0;
            bar.style.width = percent + '%';
            text.textContent = `${current} / ${total} books`;
            syncedEl.textContent = `${synced} synced`;
            errorsEl.textContent = `${errors} errors`;
        }
        
        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }
        
        function showCancelButton(show) {
            const cancelBtn = document.getElementById('cancelBtn');
            const syncBtn = document.getElementById('syncBtn');
            cancelBtn.style.display = show ? 'block' : 'none';
            syncBtn.style.display = show ? 'none' : 'block';
        }
        
        async function triggerSync() {
            const btn = document.getElementById('syncBtn');
            const token = localStorage.getItem('gh_token');
            const repo = localStorage.getItem('gh_repo');
            
            if (!token || !repo) {
                updateStatus('Setup required - configure below', 'error');
                document.getElementById('configPanel').open = true;
                return;
            }
            
            btn.disabled = true;
            btn.textContent = 'Starting...';
            updateStatus('Connecting to GitHub...', 'running');
            
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${repo}/actions/workflows/sync.yml/dispatches`,
                    {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ ref: 'main' })
                    }
                );
                
                if (response.status === 204 || response.ok) {
                    updateStatus('Sync started! Monitoring progress...', 'running');
                    showCancelButton(true);
                    
                    // Wait a moment for the run to be created, then start polling
                    setTimeout(() => startPolling(token, repo), 3000);
                } else if (response.status === 401) {
                    updateStatus('Invalid token - check your GitHub token', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Sync Now';
                } else if (response.status === 404) {
                    updateStatus('Repo not found - check username/repo', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Sync Now';
                } else {
                    const error = await response.json().catch(() => ({}));
                    updateStatus('Error: ' + (error.message || response.status), 'error');
                    btn.disabled = false;
                    btn.textContent = 'Sync Now';
                }
            } catch (e) {
                updateStatus('Error: ' + e.message, 'error');
                console.error('Sync error:', e);
                btn.disabled = false;
                btn.textContent = 'Sync Now';
            }
        }
        
        async function startPolling(token, repo) {
            // Find the latest run
            try {
                const runsResp = await fetch(
                    `https://api.github.com/repos/${repo}/actions/workflows/sync.yml/runs?per_page=1`,
                    { headers: { 'Authorization': `Bearer ${token}` } }
                );
                const runsData = await runsResp.json();
                
                if (runsData.workflow_runs && runsData.workflow_runs.length > 0) {
                    currentRunId = runsData.workflow_runs[0].id;
                    
                    // Start polling for progress
                    pollInterval = setInterval(() => pollProgress(token, repo), 5000);
                    pollProgress(token, repo); // Immediate first poll
                }
            } catch (e) {
                console.error('Failed to get run ID:', e);
            }
        }
        
        async function pollProgress(token, repo) {
            if (!currentRunId) return;
            
            try {
                // Get run status
                const runResp = await fetch(
                    `https://api.github.com/repos/${repo}/actions/runs/${currentRunId}`,
                    { headers: { 'Authorization': `Bearer ${token}` } }
                );
                const runData = await runResp.json();
                
                const status = runData.status;
                const conclusion = runData.conclusion;
                
                if (status === 'completed') {
                    stopPolling();
                    // Always check logs for cookie errors on completion
                    await fetchProgressFromLogs(token, repo);
                    if (conclusion === 'success') {
                        // Only show success if we didn't already show a cookie error
                        var currentStatus = document.getElementById('status').className;
                        if (currentStatus.indexOf('error') === -1) {
                            updateStatus('Sync completed successfully!', 'success');
                        }
                    } else if (conclusion === 'cancelled') {
                        updateStatus('Sync was cancelled', 'info');
                        hideProgress();
                    } else {
                        // Check logs to see if it was a cookie error
                        var statusEl = document.getElementById('status');
                        if (statusEl.className.indexOf('error') === -1) {
                            updateStatus('Sync failed: ' + conclusion, 'error');
                        }
                        hideProgress();
                    }
                    return;
                }
                
                // Get job logs to extract progress
                await fetchProgressFromLogs(token, repo);
                
            } catch (e) {
                console.error('Poll error:', e);
            }
        }
        
        async function fetchProgressFromLogs(token, repo) {
            try {
                // Get jobs for the run
                const jobsResp = await fetch(
                    `https://api.github.com/repos/${repo}/actions/runs/${currentRunId}/jobs`,
                    { headers: { 'Authorization': `Bearer ${token}` } }
                );
                const jobsData = await jobsResp.json();
                
                if (jobsData.jobs && jobsData.jobs.length > 0) {
                    const job = jobsData.jobs[0];
                    
                    // Try to get logs (may not be available while running)
                    try {
                        const logsResp = await fetch(
                            `https://api.github.com/repos/${repo}/actions/jobs/${job.id}/logs`,
                            { headers: { 'Authorization': `Bearer ${token}` } }
                        );
                        
                        if (logsResp.ok) {
                            const logs = await logsResp.text();
                            parseProgressFromLogs(logs);
                        }
                    } catch (logErr) {
                        // Logs may not be available yet
                        console.log('Logs not available yet');
                    }
                    
                    // Update status based on job status
                    if (job.status === 'in_progress') {
                        updateStatus('Syncing books...', 'running');
                    } else if (job.status === 'queued') {
                        updateStatus('Waiting in queue...', 'running');
                    }
                }
            } catch (e) {
                console.error('Failed to fetch logs:', e);
            }
        }
        
        function parseProgressFromLogs(logs) {
            // Check for cookie/login expiration
            if (logs.match(/ÁôªÂΩïË∂ÖÊó∂|COOKIE.*EXPIR|COOKIE.*VALIDATION.*FAIL|errCode.*-2012/i)) {
                var hasGist = !!localStorage.getItem('gh_gist_id');
                var msg = 'WeRead cookies expired! ';
                if (hasGist) {
                    msg += 'Open weread.qq.com and tap your Cookie Refresher bookmark to fix.';
                } else {
                    msg += 'Update cookies in .env & GitHub Secrets.';
                }
                updateStatus(msg, 'error');
                document.getElementById('cookiePanel').open = true;
                stopPolling();
                hideProgress();
                return;
            }
            
            // Check for cookie auth errors during sync
            if (logs.match(/COOKIE EXPIRATION DETECTED/i)) {
                var cookieErrMatch = logs.match(/(\d+)\s+API call\(s\)\s+failed due to authentication/);
                var hasGist2 = !!localStorage.getItem('gh_gist_id');
                var msg2 = 'WeRead cookies expired!';
                if (cookieErrMatch) {
                    msg2 += ' (' + cookieErrMatch[1] + ' API calls failed)';
                }
                if (hasGist2) {
                    msg2 += ' Use Cookie Refresher bookmark on weread.qq.com.';
                } else {
                    msg2 += ' Update cookies in .env & GitHub Secrets.';
                }
                updateStatus(msg2, 'error');
                document.getElementById('cookiePanel').open = true;
            }
            
            // Look for progress lines like: [PROGRESS] 10/50 books processed | ‚úÖ 9 synced | ‚ùå 1 errors
            var progressMatch = logs.match(/\[PROGRESS\]\s+(\d+)\/(\d+)\s+books?\s+processed\s*\|\s*‚úÖ\s*(\d+)\s*synced\s*\|\s*‚ùå\s*(\d+)\s*errors?/g);
            
            if (progressMatch && progressMatch.length > 0) {
                var lastProgress = progressMatch[progressMatch.length - 1];
                var match = lastProgress.match(/(\d+)\/(\d+)\s+books?\s+processed\s*\|\s*‚úÖ\s*(\d+)\s*synced\s*\|\s*‚ùå\s*(\d+)/);
                
                if (match) {
                    showProgress(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]), parseInt(match[4]));
                }
            } else {
                // Look for simpler progress: Processing X books
                var totalMatch = logs.match(/Processing\s+(\d+)\s+book/);
                if (totalMatch) {
                    showProgress(0, parseInt(totalMatch[1]), 0, 0);
                }
                
                // Count completed books from ‚úÖ lines
                var completedMatches = logs.match(/‚úÖ\s*\[\d+\/\d+\]/g);
                if (completedMatches) {
                    var totalFromLine = logs.match(/‚úÖ\s*\[\d+\/(\d+)\]/);
                    if (totalFromLine) {
                        showProgress(completedMatches.length, parseInt(totalFromLine[1]), completedMatches.length, 0);
                    }
                }
            }
        }
        
        async function fetchFinalProgress(token, repo) {
            // Same as fetchProgressFromLogs but called at the end
            await fetchProgressFromLogs(token, repo);
        }
        
        function stopPolling() {
            if (pollInterval) {
                clearInterval(pollInterval);
                pollInterval = null;
            }
            currentRunId = null;
            showCancelButton(false);
            document.getElementById('syncBtn').disabled = false;
            document.getElementById('syncBtn').textContent = 'Sync Again';
        }
        
        async function cancelSync() {
            const token = localStorage.getItem('gh_token');
            const repo = localStorage.getItem('gh_repo');
            
            if (!currentRunId || !token || !repo) {
                updateStatus('No active sync to cancel', 'info');
                return;
            }
            
            const cancelBtn = document.getElementById('cancelBtn');
            cancelBtn.textContent = 'Cancelling...';
            cancelBtn.disabled = true;
            
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${repo}/actions/runs/${currentRunId}/cancel`,
                    {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );
                
                if (response.ok || response.status === 202) {
                    updateStatus('Cancelling sync...', 'info');
                } else {
                    updateStatus('Failed to cancel', 'error');
                }
            } catch (e) {
                updateStatus('Cancel error: ' + e.message, 'error');
            }
            
            cancelBtn.textContent = 'Cancel Sync';
            cancelBtn.disabled = false;
        }
        
        function updateBookmarklet() {
            var token = localStorage.getItem('gh_token');
            var gistId = localStorage.getItem('gh_gist_id');
            var container = document.getElementById('bookmarkletContainer');
            var missing = document.getElementById('bookmarkletMissing');
            var link = document.getElementById('bookmarkletLink');
            var statusEl = document.getElementById('cookieStatus');
            
            if (token && gistId) {
                container.style.display = 'block';
                missing.style.display = 'none';
                statusEl.innerHTML = '<span class="checkmark">‚úì</span>';
                
                // Build the bookmarklet JS
                var js = "(function(){" +
                    "try{" +
                    "var c=document.cookie;" +
                    "if(!c||c.indexOf('wr_')===-1){alert('Not on weread.qq.com or not logged in!');return;}" +
                    "var pairs=c.split(';');" +
                    "var wr=[];" +
                    "for(var i=0;i<pairs.length;i++){" +
                    "var p=pairs[i].trim();" +
                    "if(p.indexOf('wr_')===0)wr.push(p);" +
                    "}" +
                    "if(wr.length===0){alert('No WeRead cookies found. Make sure you are logged in.');return;}" +
                    "var cs=wr.join('; ');" +
                    "var has_skey=false,has_vid=false,has_rt=false;" +
                    "for(var j=0;j<wr.length;j++){" +
                    "if(wr[j].indexOf('wr_skey=')===0)has_skey=true;" +
                    "if(wr[j].indexOf('wr_vid=')===0)has_vid=true;" +
                    "if(wr[j].indexOf('wr_rt=')===0)has_rt=true;" +
                    "}" +
                    "if(!has_skey||!has_vid||!has_rt){alert('Missing required cookies (wr_skey, wr_vid, wr_rt). Try refreshing the page after login.');return;}" +
                    "var x=new XMLHttpRequest();" +
                    "x.open('PATCH','https://api.github.com/gists/" + gistId + "',false);" +
                    "x.setRequestHeader('Authorization','Bearer " + token + "');" +
                    "x.setRequestHeader('Content-Type','application/json');" +
                    "x.setRequestHeader('Accept','application/vnd.github.v3+json');" +
                    "x.send(JSON.stringify({files:{'weread_cookies.txt':{content:cs}}}));" +
                    "if(x.status===200){alert('Cookies saved! ('+wr.length+' cookies)\\nNext sync will use fresh cookies.')}" +
                    "else{alert('Failed to save: '+x.status+'\\n'+x.responseText)}" +
                    "}catch(e){alert('Error: '+e.message)}" +
                    "})()";
                
                link.href = "javascript:" + encodeURIComponent(js);
            } else {
                container.style.display = 'none';
                missing.style.display = 'block';
                if (gistId && !token) {
                    statusEl.innerHTML = '<span style="color:#f87171;">Need token</span>';
                } else {
                    statusEl.innerHTML = '';
                }
            }
        }
        
        async function testGistConnection() {
            var token = localStorage.getItem('gh_token');
            var gistId = localStorage.getItem('gh_gist_id');
            var msgEl = document.getElementById('cookieStatusMsg');
            
            if (!token || !gistId) {
                msgEl.style.display = 'block';
                msgEl.className = 'cookie-status expired';
                msgEl.textContent = 'Missing token or Gist ID';
                return;
            }
            
            msgEl.style.display = 'block';
            msgEl.className = 'cookie-status';
            msgEl.textContent = 'Testing...';
            
            try {
                var resp = await fetch('https://api.github.com/gists/' + gistId, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                
                if (resp.ok) {
                    var data = await resp.json();
                    var file = data.files && data.files['weread_cookies.txt'];
                    if (file && file.content) {
                        var hasSkey = file.content.indexOf('wr_skey=') !== -1;
                        var updated = data.updated_at ? new Date(data.updated_at).toLocaleString() : 'unknown';
                        if (hasSkey) {
                            msgEl.className = 'cookie-status ok';
                            msgEl.textContent = 'Gist OK. Last updated: ' + updated;
                        } else {
                            msgEl.className = 'cookie-status expired';
                            msgEl.textContent = 'Gist found but cookies may be incomplete. Last updated: ' + updated;
                        }
                    } else {
                        msgEl.className = 'cookie-status expired';
                        msgEl.textContent = 'Gist found but weread_cookies.txt is missing';
                    }
                } else if (resp.status === 404) {
                    msgEl.className = 'cookie-status expired';
                    msgEl.textContent = 'Gist not found - check your Gist ID';
                } else if (resp.status === 401) {
                    msgEl.className = 'cookie-status expired';
                    msgEl.textContent = 'Auth failed - token may lack gist scope';
                } else {
                    msgEl.className = 'cookie-status expired';
                    msgEl.textContent = 'Error: HTTP ' + resp.status;
                }
            } catch (e) {
                msgEl.className = 'cookie-status expired';
                msgEl.textContent = 'Error: ' + e.message;
            }
        }
        
        async function testConnection() {
            const debug = document.getElementById('debugInfo');
            const token = localStorage.getItem('gh_token');
            const repo = localStorage.getItem('gh_repo');
            
            debug.innerHTML = '<p>Token: ' + (token ? token.substring(0,8) + '...' : 'NOT SET') + '</p>';
            debug.innerHTML += '<p>Repo: ' + (repo || 'NOT SET') + '</p>';
            debug.innerHTML += '<p>Testing API...</p>';
            
            try {
                // Test 1: Basic connectivity
                const testResp = await fetch('https://api.github.com/zen');
                debug.innerHTML += '<p>GitHub API reachable: ' + testResp.ok + '</p>';
                
                // Test 2: Auth check
                if (token) {
                    const authResp = await fetch('https://api.github.com/user', {
                        headers: { 'Authorization': 'Bearer ' + token }
                    });
                    const authData = await authResp.json();
                    debug.innerHTML += '<p>Auth status: ' + authResp.status + '</p>';
                    if (authResp.ok) {
                        debug.innerHTML += '<p>User: ' + authData.login + '</p>';
                    } else {
                        debug.innerHTML += '<p>Auth error: ' + (authData.message || 'Unknown') + '</p>';
                    }
                }
                
                // Test 3: Repo access
                if (token && repo) {
                    const repoResp = await fetch('https://api.github.com/repos/' + repo, {
                        headers: { 'Authorization': 'Bearer ' + token }
                    });
                    debug.innerHTML += '<p>Repo access: ' + repoResp.status + '</p>';
                }
            } catch (e) {
                debug.innerHTML += '<p style="color:#f87171;">Error: ' + e.message + '</p>';
            }
        }
        
        document.getElementById('saveBtn').addEventListener('touchend', function(e) {
            e.preventDefault();
            saveConfig();
        });
        document.getElementById('saveBtn').addEventListener('click', function(e) {
            e.preventDefault();
            saveConfig();
        });
        document.getElementById('testBookmarkletBtn').addEventListener('touchend', function(e) {
            e.preventDefault();
            testGistConnection();
        });
        document.getElementById('testBookmarkletBtn').addEventListener('click', function(e) {
            e.preventDefault();
            testGistConnection();
        });
        
        loadConfig();
    </script>
</body>
</html>
