<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sync">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìö</text></svg>">
    <title>Sync WeRead</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #fff;
        }
        .container { text-align: center; width: 100%; max-width: 400px; }
        .icon { font-size: 80px; margin-bottom: 20px; }
        h1 { font-size: 24px; margin-bottom: 30px; }
        .btn {
            display: block;
            width: 100%;
            padding: 20px;
            font-size: 20px;
            font-weight: 600;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            margin: 10px 0;
            transition: all 0.2s;
        }
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }
        .btn-primary:hover { transform: translateY(-2px); }
        .btn-primary:active { transform: scale(0.98); }
        .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .btn-cancel {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
            display: none;
        }
        .btn-cancel:hover { transform: translateY(-2px); }
        .btn-cancel:active { transform: scale(0.98); }
        .status {
            padding: 15px;
            border-radius: 12px;
            margin: 20px 0;
            min-height: 50px;
            font-size: 16px;
        }
        .status.info { background: rgba(255,255,255,0.1); }
        .status.success { background: rgba(34,197,94,0.3); }
        .status.error { background: rgba(239,68,68,0.3); }
        .status.running { background: rgba(59,130,246,0.3); animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        
        /* Progress bar styles */
        .progress-container {
            display: none;
            margin: 20px 0;
            text-align: left;
        }
        .progress-bar-bg {
            width: 100%;
            height: 24px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            overflow: hidden;
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%);
            border-radius: 12px;
            transition: width 0.5s ease;
            width: 0%;
        }
        .progress-text {
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.9;
            text-align: center;
        }
        .progress-stats {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        .config {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            text-align: left;
        }
        .config summary { cursor: pointer; font-weight: 600; padding: 10px 0; }
        .config input {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 16px;
        }
        .config input::placeholder { color: rgba(255,255,255,0.4); }
        .config label { display: block; margin-top: 15px; font-size: 14px; opacity: 0.8; }
        .config .save-btn {
            background: rgba(255,255,255,0.15);
            color: #fff;
            padding: 12px;
            font-size: 14px;
            margin-top: 15px;
        }
        .footer { margin-top: 30px; font-size: 12px; opacity: 0.5; }
        .footer a { color: #60a5fa; }
        .checkmark { color: #22c55e; margin-left: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="icon">üìö</div>
        <h1>WeRead ‚Üí Notion</h1>
        
        <button id="syncBtn" class="btn btn-primary" onclick="triggerSync()">Sync Now</button>
        <button id="cancelBtn" class="btn btn-cancel" onclick="cancelSync()">Cancel Sync</button>
        
        <div id="status" class="status info">Tap to sync your reading progress</div>
        
        <div id="progressContainer" class="progress-container">
            <div class="progress-bar-bg">
                <div id="progressBar" class="progress-bar-fill"></div>
            </div>
            <div id="progressText" class="progress-text">Preparing...</div>
            <div class="progress-stats">
                <span id="progressSynced">0 synced</span>
                <span id="progressErrors">0 errors</span>
            </div>
        </div>
        
        <details class="config" id="configPanel">
            <summary>Setup <span id="configStatus"></span></summary>
            
            <label>GitHub Token:</label>
            <input type="text" id="githubToken" placeholder="ghp_xxxxxxxxxxxx" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
            <small style="opacity:0.5;font-size:12px;">
                <a href="https://github.com/settings/tokens/new?scopes=repo,workflow&description=weread-sync" target="_blank" style="color:#60a5fa;">Get token here</a> (select repo + workflow)
            </small>
            
            <label>GitHub Repo:</label>
            <input type="text" id="githubRepo" placeholder="username/push_reading_progress_to_notion" autocorrect="off" autocapitalize="off" spellcheck="false">
            
            <button type="button" class="btn save-btn" id="saveBtn">Save Configuration</button>
        </details>
        
        <details class="config" style="margin-top:15px;">
            <summary>Debug Info</summary>
            <div id="debugInfo" style="font-size:12px;word-break:break-all;margin-top:10px;"></div>
            <button class="btn save-btn" onclick="testConnection()">Test Connection</button>
        </details>
        
        <p class="footer">
            Powered by <a href="https://github.com/actions" target="_blank">GitHub Actions</a>
        </p>
    </div>

    <script>
        let currentRunId = null;
        let pollInterval = null;
        
        function loadConfig() {
            const token = localStorage.getItem('gh_token');
            const repo = localStorage.getItem('gh_repo');
            if (token) document.getElementById('githubToken').value = token;
            if (repo) document.getElementById('githubRepo').value = repo;
            updateConfigStatus();
        }
        
        function updateConfigStatus() {
            const token = localStorage.getItem('gh_token');
            const repo = localStorage.getItem('gh_repo');
            const status = document.getElementById('configStatus');
            const panel = document.getElementById('configPanel');
            
            if (token && repo) {
                status.innerHTML = '<span class="checkmark">‚úì</span>';
                panel.open = false;
            } else {
                status.innerHTML = '<span style="color:#f87171;">‚ö† Required</span>';
                panel.open = true;
            }
        }
        
        function saveConfig() {
            var tokenEl = document.getElementById('githubToken');
            var repoEl = document.getElementById('githubRepo');
            
            // Force iOS to flush pending input
            tokenEl.blur();
            repoEl.blur();
            
            var token = tokenEl.value.trim();
            var repo = repoEl.value.trim();
            
            if (!token || !repo) {
                updateStatus('Please fill in both fields', 'error');
                return;
            }
            
            try {
                localStorage.setItem('gh_token', token);
                localStorage.setItem('gh_repo', repo);
                
                // Verify it was saved
                var saved = localStorage.getItem('gh_token');
                if (saved === token) {
                    updateStatus('Saved! Tap Sync Now to test.', 'success');
                } else {
                    updateStatus('Save failed - try disabling private browsing', 'error');
                    return;
                }
            } catch (e) {
                updateStatus('Cannot save: ' + e.message, 'error');
                return;
            }
            
            // Delay closing the panel so user sees confirmation
            setTimeout(function() { updateConfigStatus(); }, 1500);
        }
        
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
        }
        
        function showProgress(current, total, synced, errors) {
            const container = document.getElementById('progressContainer');
            const bar = document.getElementById('progressBar');
            const text = document.getElementById('progressText');
            const syncedEl = document.getElementById('progressSynced');
            const errorsEl = document.getElementById('progressErrors');
            
            container.style.display = 'block';
            
            const percent = total > 0 ? Math.round((current / total) * 100) : 0;
            bar.style.width = percent + '%';
            text.textContent = `${current} / ${total} books`;
            syncedEl.textContent = `${synced} synced`;
            errorsEl.textContent = `${errors} errors`;
        }
        
        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }
        
        function showCancelButton(show) {
            const cancelBtn = document.getElementById('cancelBtn');
            const syncBtn = document.getElementById('syncBtn');
            cancelBtn.style.display = show ? 'block' : 'none';
            syncBtn.style.display = show ? 'none' : 'block';
        }
        
        async function triggerSync() {
            const btn = document.getElementById('syncBtn');
            const token = localStorage.getItem('gh_token');
            const repo = localStorage.getItem('gh_repo');
            
            if (!token || !repo) {
                updateStatus('Setup required - configure below', 'error');
                document.getElementById('configPanel').open = true;
                return;
            }
            
            btn.disabled = true;
            btn.textContent = 'Starting...';
            updateStatus('Connecting to GitHub...', 'running');
            
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${repo}/actions/workflows/sync.yml/dispatches`,
                    {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ ref: 'main' })
                    }
                );
                
                if (response.status === 204 || response.ok) {
                    updateStatus('Sync started! Monitoring progress...', 'running');
                    showCancelButton(true);
                    
                    // Wait a moment for the run to be created, then start polling
                    setTimeout(() => startPolling(token, repo), 3000);
                } else if (response.status === 401) {
                    updateStatus('Invalid token - check your GitHub token', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Sync Now';
                } else if (response.status === 404) {
                    updateStatus('Repo not found - check username/repo', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Sync Now';
                } else {
                    const error = await response.json().catch(() => ({}));
                    updateStatus('Error: ' + (error.message || response.status), 'error');
                    btn.disabled = false;
                    btn.textContent = 'Sync Now';
                }
            } catch (e) {
                updateStatus('Error: ' + e.message, 'error');
                console.error('Sync error:', e);
                btn.disabled = false;
                btn.textContent = 'Sync Now';
            }
        }
        
        async function startPolling(token, repo) {
            // Find the latest run
            try {
                const runsResp = await fetch(
                    `https://api.github.com/repos/${repo}/actions/workflows/sync.yml/runs?per_page=1`,
                    { headers: { 'Authorization': `Bearer ${token}` } }
                );
                const runsData = await runsResp.json();
                
                if (runsData.workflow_runs && runsData.workflow_runs.length > 0) {
                    currentRunId = runsData.workflow_runs[0].id;
                    
                    // Start polling for progress
                    pollInterval = setInterval(() => pollProgress(token, repo), 5000);
                    pollProgress(token, repo); // Immediate first poll
                }
            } catch (e) {
                console.error('Failed to get run ID:', e);
            }
        }
        
        async function pollProgress(token, repo) {
            if (!currentRunId) return;
            
            try {
                // Get run status
                const runResp = await fetch(
                    `https://api.github.com/repos/${repo}/actions/runs/${currentRunId}`,
                    { headers: { 'Authorization': `Bearer ${token}` } }
                );
                const runData = await runResp.json();
                
                const status = runData.status;
                const conclusion = runData.conclusion;
                
                if (status === 'completed') {
                    stopPolling();
                    // Always check logs for cookie errors on completion
                    await fetchProgressFromLogs(token, repo);
                    if (conclusion === 'success') {
                        // Only show success if we didn't already show a cookie error
                        var currentStatus = document.getElementById('status').className;
                        if (currentStatus.indexOf('error') === -1) {
                            updateStatus('Sync completed successfully!', 'success');
                        }
                    } else if (conclusion === 'cancelled') {
                        updateStatus('Sync was cancelled', 'info');
                        hideProgress();
                    } else {
                        // Check logs to see if it was a cookie error
                        var statusEl = document.getElementById('status');
                        if (statusEl.className.indexOf('error') === -1) {
                            updateStatus('Sync failed: ' + conclusion, 'error');
                        }
                        hideProgress();
                    }
                    return;
                }
                
                // Get job logs to extract progress
                await fetchProgressFromLogs(token, repo);
                
            } catch (e) {
                console.error('Poll error:', e);
            }
        }
        
        async function fetchProgressFromLogs(token, repo) {
            try {
                // Get jobs for the run
                const jobsResp = await fetch(
                    `https://api.github.com/repos/${repo}/actions/runs/${currentRunId}/jobs`,
                    { headers: { 'Authorization': `Bearer ${token}` } }
                );
                const jobsData = await jobsResp.json();
                
                if (jobsData.jobs && jobsData.jobs.length > 0) {
                    const job = jobsData.jobs[0];
                    
                    // Try to get logs (may not be available while running)
                    try {
                        const logsResp = await fetch(
                            `https://api.github.com/repos/${repo}/actions/jobs/${job.id}/logs`,
                            { headers: { 'Authorization': `Bearer ${token}` } }
                        );
                        
                        if (logsResp.ok) {
                            const logs = await logsResp.text();
                            parseProgressFromLogs(logs);
                        }
                    } catch (logErr) {
                        // Logs may not be available yet
                        console.log('Logs not available yet');
                    }
                    
                    // Update status based on job status
                    if (job.status === 'in_progress') {
                        updateStatus('Syncing books...', 'running');
                    } else if (job.status === 'queued') {
                        updateStatus('Waiting in queue...', 'running');
                    }
                }
            } catch (e) {
                console.error('Failed to fetch logs:', e);
            }
        }
        
        function parseProgressFromLogs(logs) {
            // Check for cookie/login expiration
            if (logs.match(/ÁôªÂΩïË∂ÖÊó∂|COOKIE.*EXPIR|COOKIE.*VALIDATION.*FAIL|errCode.*-2012/i)) {
                updateStatus('WeRead cookies expired! Please refresh cookies in .env and GitHub Secrets.', 'error');
                stopPolling();
                hideProgress();
                return;
            }
            
            // Check for cookie auth errors during sync
            if (logs.match(/COOKIE EXPIRATION DETECTED/i)) {
                var cookieErrMatch = logs.match(/(\d+)\s+API call\(s\)\s+failed due to authentication/);
                var msg = 'WeRead cookies expired!';
                if (cookieErrMatch) {
                    msg += ' (' + cookieErrMatch[1] + ' API calls failed)';
                }
                msg += ' Update cookies in .env & GitHub Secrets.';
                updateStatus(msg, 'error');
            }
            
            // Look for progress lines like: [PROGRESS] 10/50 books processed | ‚úÖ 9 synced | ‚ùå 1 errors
            var progressMatch = logs.match(/\[PROGRESS\]\s+(\d+)\/(\d+)\s+books?\s+processed\s*\|\s*‚úÖ\s*(\d+)\s*synced\s*\|\s*‚ùå\s*(\d+)\s*errors?/g);
            
            if (progressMatch && progressMatch.length > 0) {
                var lastProgress = progressMatch[progressMatch.length - 1];
                var match = lastProgress.match(/(\d+)\/(\d+)\s+books?\s+processed\s*\|\s*‚úÖ\s*(\d+)\s*synced\s*\|\s*‚ùå\s*(\d+)/);
                
                if (match) {
                    showProgress(parseInt(match[1]), parseInt(match[2]), parseInt(match[3]), parseInt(match[4]));
                }
            } else {
                // Look for simpler progress: Processing X books
                var totalMatch = logs.match(/Processing\s+(\d+)\s+book/);
                if (totalMatch) {
                    showProgress(0, parseInt(totalMatch[1]), 0, 0);
                }
                
                // Count completed books from ‚úÖ lines
                var completedMatches = logs.match(/‚úÖ\s*\[\d+\/\d+\]/g);
                if (completedMatches) {
                    var totalFromLine = logs.match(/‚úÖ\s*\[\d+\/(\d+)\]/);
                    if (totalFromLine) {
                        showProgress(completedMatches.length, parseInt(totalFromLine[1]), completedMatches.length, 0);
                    }
                }
            }
        }
        
        async function fetchFinalProgress(token, repo) {
            // Same as fetchProgressFromLogs but called at the end
            await fetchProgressFromLogs(token, repo);
        }
        
        function stopPolling() {
            if (pollInterval) {
                clearInterval(pollInterval);
                pollInterval = null;
            }
            currentRunId = null;
            showCancelButton(false);
            document.getElementById('syncBtn').disabled = false;
            document.getElementById('syncBtn').textContent = 'Sync Again';
        }
        
        async function cancelSync() {
            const token = localStorage.getItem('gh_token');
            const repo = localStorage.getItem('gh_repo');
            
            if (!currentRunId || !token || !repo) {
                updateStatus('No active sync to cancel', 'info');
                return;
            }
            
            const cancelBtn = document.getElementById('cancelBtn');
            cancelBtn.textContent = 'Cancelling...';
            cancelBtn.disabled = true;
            
            try {
                const response = await fetch(
                    `https://api.github.com/repos/${repo}/actions/runs/${currentRunId}/cancel`,
                    {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    }
                );
                
                if (response.ok || response.status === 202) {
                    updateStatus('Cancelling sync...', 'info');
                } else {
                    updateStatus('Failed to cancel', 'error');
                }
            } catch (e) {
                updateStatus('Cancel error: ' + e.message, 'error');
            }
            
            cancelBtn.textContent = 'Cancel Sync';
            cancelBtn.disabled = false;
        }
        
        async function testConnection() {
            const debug = document.getElementById('debugInfo');
            const token = localStorage.getItem('gh_token');
            const repo = localStorage.getItem('gh_repo');
            
            debug.innerHTML = '<p>Token: ' + (token ? token.substring(0,8) + '...' : 'NOT SET') + '</p>';
            debug.innerHTML += '<p>Repo: ' + (repo || 'NOT SET') + '</p>';
            debug.innerHTML += '<p>Testing API...</p>';
            
            try {
                // Test 1: Basic connectivity
                const testResp = await fetch('https://api.github.com/zen');
                debug.innerHTML += '<p>GitHub API reachable: ' + testResp.ok + '</p>';
                
                // Test 2: Auth check
                if (token) {
                    const authResp = await fetch('https://api.github.com/user', {
                        headers: { 'Authorization': 'Bearer ' + token }
                    });
                    const authData = await authResp.json();
                    debug.innerHTML += '<p>Auth status: ' + authResp.status + '</p>';
                    if (authResp.ok) {
                        debug.innerHTML += '<p>User: ' + authData.login + '</p>';
                    } else {
                        debug.innerHTML += '<p>Auth error: ' + (authData.message || 'Unknown') + '</p>';
                    }
                }
                
                // Test 3: Repo access
                if (token && repo) {
                    const repoResp = await fetch('https://api.github.com/repos/' + repo, {
                        headers: { 'Authorization': 'Bearer ' + token }
                    });
                    debug.innerHTML += '<p>Repo access: ' + repoResp.status + '</p>';
                }
            } catch (e) {
                debug.innerHTML += '<p style="color:#f87171;">Error: ' + e.message + '</p>';
            }
        }
        
        document.getElementById('saveBtn').addEventListener('touchend', function(e) {
            e.preventDefault();
            saveConfig();
        });
        document.getElementById('saveBtn').addEventListener('click', function(e) {
            e.preventDefault();
            saveConfig();
        });
        
        loadConfig();
    </script>
</body>
</html>
